Что выведет программа? Объяснить вывод программы. Объяснить как работают
defer’ы и порядок их вызовов.
```go
package main
import (
	"fmt"
)
func test() (x int) {   // возврат именованный, можно изменить возвращаемое значение посредством отложенного вызова функции
	defer func() {
		x++
	}()
	x = 1
	return
}
func anotherTest() int { // возврат не именованный, невозможно изменить возвращаемое значение посредством отложенного вызова функции
	var x int
	defer func() {
		x++
	}()
	x = 1
	return x
}
func main() {
	fmt.Println(test())
	fmt.Println(anotherTest())
}
```

Ответ:
```
2
1

  Область возврата в первом случае test() (x int) является именованной и к ней можно
обратиться, поэтому при Дефере мы обращаемся и успешно инкрементим х. Во втором случае
область возврата является анонимной и программа в Дефере меняет локальную переменную,
что никак не влияет на возвращаемое значение.

    Выражение defer добавляет вызов функции после ключевого слова defer в стеке приложения.
 Все вызовы отложенных функций фактически осуществляются при возврате из функции (после return), в которой они были добавлены, но до момента получения значения вызывающей стороной.
 Поскольку вызовы помещаются в стек, они производятся в порядке от последнего к первому.
 При вычислении выражения с defer (например, defer Add(a, b)) аргументы отложенной функции вычисляются немедленно.
 Defer может читать/писать в именованный возврат
 
    1. Аргументы отложенного вызова функции вычисляются тогда, когда вычисляется команда defer.

В этом примере выражение «i» вычисляется, когда откладывается вызов Println. Отложенный вызов напечатает «0» после возврата из функции.

func a() {
    i := 0
    defer fmt.Println(i)
    i++
    return
}

2. Отложенные вызовы функций выполняются в порядке LIFO: последний отложенный вызов будет вызван первым — после того, как объемлющая функция завершит выполнение.

Эта функция напечатает «3210»:

func b() {
    for i := 0; i < 4; i++ {
        defer fmt.Print(i)
    }
}

3. Отложенные функции могут читать и устанавливать именованные возвращаемые значения объемлющей функции.

В этом примере отложенная функция увеличивает возвращаемое значение i после того, как объемлющая функция завершит выполнение. Так, эта функция возвращает 2:

func c() (i int) {
    defer func() { i++ }()
    return 1
}
  