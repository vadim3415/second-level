package main

import (
	"fmt"
)

/*
Factory (фабрика)

Суть паттерна практически полностью описывается его названием. Когда вам требуется получать какие-то объекты, например пакеты сока, 
вам совершенно не нужно знать как их делают на фабрике. Вы просто говорите «сделайте мне пакет апельсинового сока», 
а «фабрика» возвращает вам требуемый пакет. Как? Всё это решает сама фабрика, например «копирует» уже существующий эталон. 
Основное предназначение «фабрики» в том, чтобы можно было при необходимости изменять процесс «появления» пакета сока, 
а самому потребителю ничего об этом не нужно было сообщать, чтобы он запрашивал его как и прежде.
Как правило, одна фабрика занимается «производством» только одного рода «продуктов». Не рекомендуется «фабрику соков» 
создавать с учетом производства автомобильных покрышек. Как и в жизни, паттерн «фабрика» часто создается «одиночкой».

	Применяется кода:
	- Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
	Фабричный метод отделяет код производства продуктов от остального кода, который эти продукты использует.
	- Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.
	Преимущества:
	- Избавляет класс от привязки к конкретным классам продуктов.
	- Выделяет код производства продуктов в одно место, упрощая поддержку кода.
	- Упрощает добавление новых продуктов в программу.
	- Реализует принцип открытости/закрытости.

	Минусы:
	1. Может привести к созданию больших параллельных иерархий классов,
		так как для каждого класса продукта надо создать свой подкласс создателя.
*/

type Animal interface {
	Pet()
}

type pet struct {
	name  string
	age   int
	sound string
}

type dog struct {
	pet
}

func (p *dog) Pet() {
	fmt.Printf("Dog: name is %s, age %d, sound %s\n", p.name, p.age, p.sound)
}

func Dog() Animal {
	return &dog{
		pet{
			name:  "sharik",
			age:   2,
			sound: "bark",
		},
	}
}

type cat struct {
	pet
}

func (p *cat) Pet() {
	fmt.Printf("Cat: name is %s, age %d, sound %s\n", p.name, p.age, p.sound)
}

func Cat() Animal {
	return &cat{
		pet{
			name:  "matroskin",
			age:   2,
			sound: "meow",
		},
	}
}

func factoryAnimal(animal string) Animal {
	switch animal {
	case "dog":
		return Dog()
	case "cat":
		return Cat()
	default:
		return nil
	}

}
func main() {
	dog := factoryAnimal("dog")
	dog.Pet()

	cat := factoryAnimal("cat")
	cat.Pet()

}
